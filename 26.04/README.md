# Домашнее задание №2 к 05.04. 

## Описание скриптов.
### `run.sh`
Действия, выполняемые скриптом:
1. Создает docker сеть `redis-network` для подключения redis-контейнеров к одной сети.
2. Поднимает 3 redis-контейнера, в каждом запускает по master-инстансу redis-server'а.
3. На каждом из контейнеров запускает по slave-инстансу redis-server'а для обеспечения отказоустойчивости.
4. Подключается к одной из master-нод и запускает процесс объединения всех нод в кластер, `cluster-replica` равна 1 (у каждого master'а есть один свой slave).
5. Проверяет состояние кластера, выводит соответствующую информацию в консоль.
6. Поднимает контейнер с python-приложением, подключает его к сети `redis-network` и запускает приложение.
7. Приложение подключается к кластеру и заполняет его данными из генератора.
8. Выводит логи приложения в консоль.
    - Количество сгенерированных сущностей.
    - Вес JSON объекта, если бы мы все эти данные сохранили как dump (количество подобрано так, чтобы на кластер загрузилось примерно 22 мегабайта данных). 
9.  Выводит информацию о кластере в консоль: 
    - распределение ключей
    - количество хранимых ключей на каждой из нод
    - общее количество ключей на кластере
10. Запускает команду `redis-benchmark` на кластера с чтением и записью `100000` строк, используя `100` клиентов и `16` потоков.
11. Выводит результаты benchmark'а в консоль.

### `clean.sh`
Скрипт для удаления всех созданных контейнеров, виртуальных окружений и т.д.
Действия, выполняемые скриптом:
1. Останавливает, если запущен, контейнер с python-приложением.
2. Останавливает кластер redis-серверов.
3. Удаляет сгенерированные данные кластером.
4. Удаляет `redis-network`.
---

## Подробнее про структуру проекта.
### Docker.
В директории `docker/` лежат файлы для создания контейнеров:
- `docker-compose.yml` - файл для запуска контейнеров с помощью `docker-compose`, в нем указаны три сервиса, в каждом предварительно копируются конфигурации для `master` и `slave` инстансов `redis-server`.
- `Dockerfile.python` - файл для создания контейнера с python-приложением, в нем копируется файл `requirements.txt` и устанавливаются зависимости из него, а также запускаются генератор и приложение, заполняющее кластер данными.
- `Dockerfile.redis` - файл для создания контейнера с redis-server'ом, в нем просто указан образ `redis:latest`.

### Redis Cluster.
В директории `redis-cluster/` лежат файлы для конфигурации кластера:
- Три файла `master{i}.conf` - конфигурации для `master` инстансов `redis-server`.
- Три файла `slave{i}.conf` - конфигурации для `slave` инстансов `redis-server`.

### Python-приложение.
В директории `redis-app/` лежат файлы для генерации данных, а также заполнения кластера данными:
- `requirements.txt` - файл с зависимостями для python-приложения.
- `utils/` - директория с утилитами, которые используются в приложении:
    - `generator.py` - модуль для генерации данных.
    - `redis_data_inserter.py` - модуль для заполнения кластера данными.
- `main.py` - точка входа в приложение, в ней происходит подключение к кластеру и запуск генератора и заполнения кластера данными.

---

## Про генерацию данных.
Для генерации данных используется модуль `redis-app/utils/generator.py`, в нем реализован класс `Generator`, который генерирует данные в формате JSON.

Предметная область: интернет-магазин.
Сущности: товары, пользователи (активные/все), заказы(активные/все).

Данные генерируются следующим образом:
1. Генерируется 400 товаров. Каждый товар случайным образом получает следующие поля: 
   - `product_id` - порядковый номер при генерации (от `1` до `400`)
   - `name` - последовательность символов длиной `10`.
   - `price` - число из диапазона от `1` до `1000`.
2. Генерируется топ-100 товаров, которые пользователи чаще всего добавляют в корзину. Это список из пар:
    - `product_id` - случайное число из диапазона [`1`,  `400`] (товар из списка)
    - `rating` - случайное число из диапазона [`1000`, `10000`] (оценка пользователя)  
3. На основе списка товаров генерируются пользователи. Общее количество пользователей выбирается случайно из диапазона [`100_000`, `105_000`]. Каждый пользователь случайным образом получает следующие поля:
     - `user_id` - число из диапазона от `1` до `1_000_000`
     - `name` - последовательность символов длиной `6`.
     - `created` - `timestamp` создания пользователя, берется за последние `4` дня.
     - `cart` - список товаров, которые пользователь добавил в корзину, их количество в корзине выбирается из диапазона [`4`, `6`], каждая позиция в корзине описывается строкой `"{product_id} {amount}"`.
4. На основе пользователей и товаров генерируются активные заказы. Общее количество заказов равно `3 * |users|`. Каждый заказ случайным образом получает следующие поля:
     - `order_id` - порядковый номер при генерации (от `1` до `3 * |users|`)
     - `user_id` - `id` пользователя, который сделал заказ (выбирается из пользователей).
     - `product_id` - `product_id` товара, который пользователь заказал (выбирается из товаров).
     - `amount` - количество соответствующего продукта, берется из диапазона [`5`, `10`].

Помимо основных сущностей генерируются еще две дополнительные структуры:
1. Структура `active_orders`, которая хранит биекцию (map) между `order_id` и строкой, описывающей заказ, `"{product_id} {amount}"`.
2. Структура `active_users`, которая хранит список активных на сайте пользователей.

Данные структуры добавлены для того, чтобы использовать как можно больше структур из `redis`, а также для того, чтобы было удобно искать данные в кластере.

---

## Про заполнение кластера данными.
Для заполнения кластера данными используется модуль `redis-app/utils/redis_data_inserter.py`, в нем реализован класс `RedisDataInserter`, который заполняет кластер данными.

В кластере создаются следующие структуры:
1. Структура `user:{user_id}`, `hashset`, для каждого пользователя, в которой хранятся поля `name` и `created` с соответствующими значениями.
2. Структура `product:{product_id}`, `hashset`, для каждого продукта, в которой хранятся поля `name` и `price` с соответсвующими значениями.
3. Структура `top_rated_products`, `sorted set / zset`, в которой хранятся пары `product_id` и `rating` для топ-100 товаров.
4. Структура `active_orders`, `hashset`, в которой хранятся биекции между `order_id` и строкой, описывающей заказ, `"{product_id} {amount}"`.
5. Структура `active_users`, `set`, в которой хранятся `user_id` активных пользователей.
6. Структура `active_order_user`, `hashset`, в которой хранятся биекции между `order_id` и `user_id` пользователя, который сделал заказ.
7. Структура `user:{user_id}:cart`, `list`, для каждого пользователя, в которой хранится список продуктов, которые пользователь добавил в корзину (каждый продукт имеет вид `"{product_id} {amount}"`).

---

## Логи и результаты `redis-benchmark`.

Пример одной из генераций данных и заполнения кластера:

| Entity        | Count     |
|---------------|-----------|
| Products      | 400       |
| Users         | 102655    |
| Active orders | 307965    |
| Size          | 22.69 MBs |
| Time          | 180.57 s  |

`Time` - время вставки данного объема данных и дополнительных структур в кластер.

Dbsize на различных нодах на примере данных выше:
| Node  | dbsize |
|-------|--------|
| 1     | 65519  |
| 2     | 64869  |
| 3     | 65356  |
| Total | 195744 |

Видно, что данные растекаются равномерно по нодам.

Пример результатов `redis-benchmark`:

| test| rps       | avg_latency_ms | min_latency_ms | p50_latency_ms | p95_latency_ms | p99_latency_ms | max_latency_ms |
|-----|-----------|----------------|----------------|----------------|----------------|----------------|----------------|
| SET | 392156.88 | 1.571          | 0.152          | 1.135          | 3.967          | 12.391         | 19.487         |
| GET | 398406.41 | 1.711          | 0.152          | 1.047          | 4.071          | 18.655         | 29.439         |

Все приведенные таблицы можно увидеть, запустив локально `run.sh`, который выведет результаты в консоль. 
После запуска, не забудьте удалить созданные контейнеры, выполнив `clean.sh`.